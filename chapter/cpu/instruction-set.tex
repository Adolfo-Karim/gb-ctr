%!TEX root = ../../gbctr.tex
%!TEX program = xelatex
\providecommand{\main}{../..}
\documentclass[\main/gbctr.tex]{subfiles}
\begin{document}

\chapter{Sharp SM83 instruction set}

\section{8-bit load and store instructions}

\section{16-bit load and store instructions}

\section{8-bit arithmetic instructions}

\section{16-bit arithmetic instructions}

\section{Rotate, shift, and bit operation instructions}

\section{Control flow instructions}

\subsection{JP nn}
\label{inst:JP}

Unconditional jump to the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{11000011}/\hex{C3} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{JP nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xC3:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  PC = nn
\end{verbatim}
\end{description}

\subsection{JP HL}
\label{inst:JP_HL}

Unconditional jump to the absolute address specified by the 16-bit register HL.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11101001}/\hex{E9}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{JP HL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{HL} X \\
    \end{tikztimingtable}
  }
  \item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xE9:
  PC = HL
\end{verbatim}
\end{description}

\begin{warning}
  In some documentation this instruction is written as \texttt{JP [HL]}. This
  is very misleading, since brackets are usually used to indicate a memory
  read, and this instruction simply copies the value of HL to PC.
\end{warning}

\subsection{JP cc, nn}
\label{inst:JP_cc}

Conditional jump to the absolute address specified by the 16-bit operand \texttt{nn}, depending on the condition \texttt{cc}.

Note that the operand (absolute address) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{110cc010}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    3 machine cycles (cc=false), or 4 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JP cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{JP cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC2, 0xD2, 0xCA, 0xDA]:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  if F.check_condition(cc):
    PC = nn
\end{verbatim}
\end{description}

\subsection{JR e}
\label{inst:JR}

Unconditional jump to the relative address specified by the signed 8-bit operand \texttt{e}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{00011000}/\hex{18} + offset \texttt{e}
  \item[Length]
    2 bytes
  \item[Duration]
    3 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JR e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8U ; [opacity=0.4] 8D{PC+2+e} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x18:
  e = signed_8(read(PC++))
  PC = PC + e
\end{verbatim}
\end{description}

\subsection{JR cc, e}
\label{inst:JR_cc}

Conditional jump to the relative address specified by the signed 8-bit operand \texttt{e}, depending on the condition \texttt{cc}.

Note that the operand (relative address offset) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{001cc000}/various + offset \texttt{e}
  \item[Length]
    2 bytes
  \item[Duration]
    2 machine cycles (cc=false), or 3 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{JR cc, e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1}; [opacity=0.4] 8D{PC+2} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{JR cc, e} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: e} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8U ; [opacity=0.4] 8D{PC+2+e} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0x20, 0x30, 0x28, 0x38]:
  e = signed_8(read(PC++))
  if F.check_condition(cc):
    PC = PC + e
\end{verbatim}
\end{description}

\subsection{CALL nn}
\label{inst:CALL}

Unconditional function call to the absolute address specified by the 16-bit operand \texttt{nn}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{11001101}/\hex{CD} + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    6 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6} 8D{M7/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 48D{CALL nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U 8D{W: msb(PC+3)} 8D{W: lsb(PC+3)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xCD:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  write(--SP, msb(PC))
  write(--SP, lsb(PC))
  PC = nn
\end{verbatim}
\end{description}

\subsection{CALL cc, nn}
\label{inst:CALL_cc}

Conditional function call to the absolute address specified by the 16-bit operand \texttt{nn}, depending on the condition \texttt{cc}.

Note that the operand (absolute address) is read even when the condition is false!

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode + data]
    \bin{110cc100}/various + LSB of \texttt{nn} + MSB of \texttt{nn}
  \item[Length]
    3 bytes
  \item[Duration]
    3 machine cycles (cc=false), or 6 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 24D{CALL cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} ; [opacity=0.4] 8D{PC+3} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6} 8D{M7/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 48D{CALL cc, nn} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(nn)} 8D{R: msb(nn)} 8U 8D{W: msb(PC+3)} 8D{W: lsb(PC+3)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{PC+1} 8D{PC+2} 8U 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{nn} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC4, 0xD4, 0xCC, 0xDC]:
  nn = unsigned_16(lsb=read(PC++), msb=read(PC++))
  if F.check_condition(cc):
    write(--SP, msb(PC))
    write(--SP, lsb(PC))
    PC = nn
\end{verbatim}
\end{description}

\subsection{RET}
\label{inst:RET}

Unconditional return from a function.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11001001}/\hex{C9}
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RET} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xC9:
  PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\subsection{RET cc}
\label{inst:RET_cc}

Conditional return from a function, depending on the condition \texttt{cc}.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{110cc000}/various
  \item[Length]
    1 byte
  \item[Duration]
    2 machine cycles (cc=false), or 5 machine cycles (cc=true)
  \item[Flags]
    -
  \item[Timing (cc=false)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 16D{RET cc} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
  \item[Timing (cc=true)] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5} 8D{M6/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 40D{RET cc} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC0, 0xD0, 0xC8, 0xD8]:
  if F.check_condition(cc):
    PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
\end{verbatim}
\end{description}

\subsection{RETI}
\label{inst:RETI}

Unconditional return from a function. Also enables interrupts by setting IME=1.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11011001}/\hex{D9}
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RETI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8D{R: lsb(PC)} 8D{R: msb(PC)} 8U ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8D{SP} 8D{SP+1} 8U ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xD9:
  PC = unsigned_16(lsb=read(SP++), msb=read(SP++))
  IME = 1
\end{verbatim}
\end{description}

\subsection{RST n}
\label{inst:RST}

Unconditional function call to the absolute fixed address defined by the opcode.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11xxx111}/various
  \item[Length]
    1 byte
  \item[Duration]
    4 machine cycles
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2} 8D{M3} 8D{M4} 8D{M5/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 32D{RST n} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} 8U 8D{W: msb(PC+3)} 8D{W: lsb(PC+3)} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} 8U 8D{SP-1} 8D{SP-2} ; [opacity=0.4] 8D{new PC} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode in [0xC7, 0xD7, 0xE7, 0xF7, 0xCF, 0xDF, 0xEF, 0xFF]:
  n = rst_address(opcode)
  write(--SP, msb(PC))
  write(--SP, lsb(PC))
  PC = unsigned_16(lsb=n, msb=0x00)
\end{verbatim}
\end{description}

\section{Miscellaneous instructions}

\subsection{HALT}
\label{inst:HALT}

\subsection{STOP}
\label{inst:STOP}

\subsection{DI}
\label{inst:DI}

Disables interrupt handling by setting IME=0 and cancelling any scheduled
effects of the EI instruction if any.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11110011}/\hex{F3}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{DI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xF3:
  IME = 0
\end{verbatim}
\end{description}

\subsection{EI}
\label{inst:EI}

Schedules interrupt handling to be enabled after the next machine cycle.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{11111011}/\hex{FB}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle (+ 1 machine cycle for the effect)
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{EI} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0xFB:
  IME_scheduled = true
\end{verbatim}
\end{description}

\subsection{CCF}
\label{inst:CCF}

Flips the carry flag, and clears the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00111111}/\hex{3F}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 0, H = 0, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{CCF} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x3F:
  flags.N = 0
  flags.H = 0
  flags.C = ~flags.C
\end{verbatim}
\end{description}

\subsection{SCF}
\label{inst:SCF}

Sets the carry flag, and clears the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00110111}/\hex{37}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 0, H = 0, C = 1
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{SCF} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x37:
  flags.N = 0
  flags.H = 0
  flags.C = 1
\end{verbatim}
\end{description}

\subsection{NOP}
\label{inst:NOP}

No-operation. This instruction doesn't do anything, but can be used to add a
delay of one machine cycle and increment PC by one.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00000000}/\hex{00}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    -
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{NOP} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x00:
  // nothing
\end{verbatim}
\end{description}

\subsection{DAA}
\label{inst:DAA}

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00100111}/\hex{27}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    Z = \faStar, H = 0, C = \faStar
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{DAA} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\end{description}

\subsection{CPL}
\label{inst:CPL}

Flips all the bits in the 8-bit A register, and sets the N and H flags.

\begin{description}[leftmargin=9em, style=nextline]
  \item[Opcode]
    \bin{00101111}/\hex{2F}
  \item[Length]
    1 byte
  \item[Duration]
    1 machine cycle
  \item[Flags]
    N = 1, H = 1
  \item[Timing] \parbox{\linewidth}{
    \begin{tikztimingtable}[timing/wscale=0.8]
      M-cycle & X 8D{M1} 8D{M2/M1} X \\
      Instruction & ; [opacity=0.4] 9D{Previous} ; [opacity=1.0] 8D{CPL} ; [opacity=0.4] X \\
      Mem R/W  & X 8D{R: opcode} ; [opacity=0.4] 8D{R: next op} X \\
      Mem addr & X 8D{PC} ; [opacity=0.4] 8D{PC+1} X \\
    \end{tikztimingtable}
  }
\item[Pseudocode] \begin{verbatim}
opcode = read(PC++)
if opcode == 0x2F:
  A = ~A
  flags.N = 1
  flags.H = 1
\end{verbatim}
\end{description}

\end{document}
